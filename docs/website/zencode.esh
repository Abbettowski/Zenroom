# Smart contracts in human language

Zenroom is software inspired by the [language-theoretical
security](http://langsec.org) research and it allows to express
cryptographic operations in a readable domain-specific language called
**Zencode**.

See the [Zencode Whitepaper](https://files.dyne.org/zenroom/Zencode_Whitepaper.pdf).

Or this blog post: [Smart contracts for the English speaker](https://decodeproject.eu/blog/smart-contracts-english-speaker).

Now lets dive into some examples to learn this very simple language. Be mindful: boxes contain executable Zencode.

# Attribute Based Credentials

![Alice in Wonderland](img/alice_with_cards-sm.jpg)

Let's now imagine 3 different subjects for our scenarios:

1. **Mad Hatter** is a well known **issuer** in Wonderland
2. **Wonderland** is an open space, all inhabitants can check the validity of **proofs**
3. **Alice** just arrived: will request a **signature** by an **issuer** to create **proofs**
3. **Mad Hatter** may accept to sign them

When in possession of **credentials**, Alice can enter any room in
Wonderland and drop a **proof** in the chest at its entrance. This
proof can be verified by anyone without knowing this is Alice.

Alice cannot be followed by her trail of proofs. Alice can produce an
infinite number of proofs for anyone to witness their validity without
even knowing who she is.

![Zencode for attribute based credentials](img/zkp_abc.svg)

1- **Alice** generates her **credential keypair**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED01.zen)" %>
```
2- **MadHatter** generates an **issuer keypair**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED03.zen)" %>
```
2a **MadHatter** publishes the **verification key**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED04.zen)" %>
```
3- **Alice** sends her **credential signature request**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED02.zen)" %>
```
4- **MadHatter** decides to sign a **credential signature request**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED05.zen)" %>
```
5- **Alice** receives and aggregates the signed **credential**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED06.zen)" %>
```

-----

At this point **Alice** is in possession of **credentials** allowing
her to produce a **proof** any time she wants.

-----

6- **Alice** show the **credential proof**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED07.zen)" %>
```

7- Anyone can verify the **credential proof**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED08.zen)" %>
```

# Zero Knowledge Proofs

One powerful feature of Zenroom is the implementation of the [Coconut
crypto scheme](https://arxiv.org/pdf/1802.07344.pdf). This novel
scheme supports several features based on pairing elliptic curve
arithmetics and in particular:

- non-interactive zero knowedge proofs (also known as ZK, ZKP or ZK-Snarks)
- threshold credentials with multiple decentralised issuers
- homomorphic encryption for numeric counters

These are all very useful features for architectures based on the
decentralisation of trust, typical of DLT and blockchain based
systems, as well for off-line and non-interactive authentication.

The Zencode language leverages two main use cases of this crypto
scheme and two more will be implemented in the future.

1. Attribute Based Credentials (ABC) where issuer verification keys
   represent specific credentials
2. A Petition system based on ABC and homomorphic encryption
3. (WIP) Anonymous proxy validation scheme
4. (WIP) Token thumbler to privately transfer numeric assets

The main feature of ZKP based cryptography is that one can use
credentials to create untreaceable public proofs for authenticating or
signing a petition etc.

The validity of ZK proofs can be witnesses by anyone without even
knowing who is being authenticated: just knowing the proof and the
credential (the public verification key of the credential issuer).





# Memory model

Zencode contracts operate in 3 phases:

1. **Given** - validates the input
2. **When** - processes the contents
3. **Then** - prints out the results

The 3 separate blocks of code also correspond to 3 separate memory areas, sealed by some security measures.

![Zencode documentation diagram](img/zencode_diagram.png)

All data processed has first to pass the validation phase according to scenario specific data schemas.

**Good Practice**: start your Zencode noting down the Zenroom version you are using!

```
rule check version 1.0.0
```



## Given

### Self introduction

This affects **my** statements

```cucumber
Given I introduce myself as ''
Given I am known as ''
Given I am ''
Given I have my ''
Given I have my valid ''
```

Data provided as input (from **data** and **keys**) is all imported
automatically from **JSON** or [CBOR](https://tools.ietf.org/html/rfc7049) binary formats.

Scenarios can add Schema for specific data validation mapped to **words** like: **signature**, **proof** or **secret**.


**Data input**
```cucumber
Given I have a ''
Given I have a valid ''
Given I have a '' inside ''
Given I have a valid '' inside ''
Given I have a '' from ''
Given I have a valid '' from ''
Given the '' is valid
```

or check emptyness:

```cucumber
Given nothing
```

When **valid** is specified then extra checks are made on input value,
mostly according to the **scenario**

**Settings**
```txt
rule input encoding [ url64 | base64 | hex | bin ]
rule input format [ json | cbor ]
```

## When

Processing data is done in the when block. Also scenarios add statements to this block.

Without extensions, these are the basic functions available

```yaml
when:
  - {when: 'I append '''' to '''''}
  - {when: 'I write '''' in '''''}
  - {when: 'I set '''' to '''''}
  - {when: 'I create a random '''''}
  - {when: 'I create a random array of '''' elements'}
  - {when: 'I create a random '''' bit array of '''' elements'}
  - {when: 'I set '''' as '''' with '''''}
  - {when: 'I append '''' as '''' to '''''}
  - {when: 'I write '''' as '''' in '''''}
```

## Then

Output is all exported in JSON or CBOR

```yaml
then:
  - {then: 'print '''' '''''}
  - {then: 'print all data'}
  - {then: 'print my data'}
  - {then: 'print my data'}
  - {then: 'print my '''''}
  - {then: 'print as '''' my '''''}
  - {then: 'print my '''' as '''''}
  - {then: 'print the '''''}
  - {then: 'print as '''' the '''''}
  - {then: 'print as '''' the '''' inside '''''}
```

Settings:
```txt
rule output encoding [ url64 | base64 | hex | bin ]
rule output format [ json | cbor ]
```
# Symmetric encryption 

This is a simple tecnique to hide a secret using a common password known to all people.

```yaml
# a `message` must be set and will be used as encryption input 
# if a `header` is set will authenticate to destination
  - {when: 'I encrypt the message with '''''}
  - {when: 'I decrypt the secret message with '''''}
# encryption output is returned in `secret message`
```

Let's imagine I want to share a secret with someone and send secret messages encrypted with it:

![Zencode to encrypt with password](img/aes_crypt.svg)

I will need 3 Zencode contracts executed at different times:

**1. I generate a strong random secret**
```cucumber
<%= "$(cat ../test/zencode_simple/SYM01.zen)" %>
```
-> then save the secret output and send it

**2. I encrypt a message using this secret**
```cucumber
<%= "$(cat ../test/zencode_simple/SYM02.zen)" %>
```
-> then save the secret message and send it

**3. Who has my secret can decrypt the secret message**
```cucumber
<%= "$(cat ../test/zencode_simple/SYM03.zen)" %>
```

Of course the secret must be known by all participats and that's the
dangerous part, since it could be stolen at the moment is told.

We solve this problem using public-key cryptography, also known as a-symmetric encryption.

# Asymmetric encryption

To solve this problem we have [asymmetric encryption (or public key
cryptography)](https://en.wikipedia.org/wiki/Public-key_cryptography)
which relies on the creation of keypairs (public and private) both by
Alice and Bob.

Fortunately its pretty simple to do using Zencode.

## Key generation and exchange

```yaml
  - {when: 'I create my new keypair'}
  - {when: 'I generate my keys'}
```

![Zencode to generate asymmetric keypairs](img/ecdh_keygen.svg)

After both Alice and Bob have their own keypairs and they both know
each other public key we can move forward to do asymmetric encryption
and signatures.

**1.a Alice keygen**
```cucumber
<%= "$(cat ../test/zencode_simple/AES01.zen)" %>
```

**2.a Alice pubkey**
```cucumber
<%= "$(cat ../test/zencode_simple/AES02.zen)" %>
```

**1.b Bob keygen**
```cucumber
<%= "$(cat ../test/zencode_simple/AES03.zen)" %>
```

**2.b Bob pubkey**
```cucumber
<%= "$(cat ../test/zencode_simple/AES04.zen)" %>
```

## Public-key Encryption (ECDH)

```yaml
  # if a 'header' is set will authenticate to destination
  - {when: 'I encrypt the '''' to '''' for '''''}
  - {when: 'I decrypt the '''' from '''' to '''''}
```

![Zencode to encrypt using asymmetric keypairs](img/ecdh_crypt.svg)


**1. Alice encrypts the message using Bob's public key**
```cucumber
<%= "$(cat ../test/zencode_simple/AES05.zen)" %>
```

**2. Bob prepares a keyring with Alice's public key**
```cucumber
<%= "$(cat ../test/zencode_simple/AES06.zen)" %>
```

**3. Bob decrypts the message using Alice's public key**
```cucumber
<%= "$(cat ../test/zencode_simple/AES07.zen)" %>
```

In this basic example the session key for encryption is made combining
the private key of Alice and the public key of Bob (or
viceversa).

```cucumber
When I write 'my secret for you' in 'message'
and I write 'an authenticated message' in 'header'
```

The decryption will always check that the header hasn't changed,
maintaining the integrity of the string which may contain important
public information that accompany the secret.

## Public-key Signature (ECDSA)

```yaml
  - {when: 'I sign the '''' as '''''}
  - {when: 'I verify the '''' is authentic'}
```

![Zencode to sign using asymmetric keypairs](img/ecdsa_sign.svg)

Here we continue assuming that the keyrings are already prepared with
public/private keypairs and the public keypair of the correspondent.

**1. Alice signs a message for Bob**
```cucumber
<%= "$(cat ../test/zencode_simple/DSA01.zen)" %>
```

**1. Bob verifies the signed message from Alice**
```cucumber
<%= "$(cat ../test/zencode_simple/DSA02.zen)" %>
```

In this example Alice uses her private key to sign and authenticate a
message. Bob or anyone else can use Alice's public key to prove that
the integrity of the message is kept intact and that she signed it.






# Full list of statements

```yaml
<%= "$(cat zencode_utterances.yaml)" %>
```
