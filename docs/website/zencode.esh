# Smart contracts in human language

Zenroom is software inspired by the [language-theoretical
security](http://langsec.org) research and it allows to express
cryptographic operations in a readable domain-specific language called
**Zencode**.

For an explanation of the innovation brought by Zencode see this blog post: [Smart contracts for the English speaker](https://decodeproject.eu/blog/smart-contracts-english-speaker).

Now to learn this very simple language, lets dive into some examples.

Keep in mind that statements in yellow boxes are actual Zencode being executed.

# Memory model

Zencode contracts operate in 3 phases:

1. **Given** - validates the input
2. **When** - processes the contents
3. **Then** - prints out the results

The 3 separate blocks of code also correspond to 3 separate memory areas, sealed by some security measures.

![Zencode documentation diagram](img/zencode_diagram.png)

All data processed has first to pass the validation phase according to scenario specific data schemas.

**Good Practice**: start your Zencode noting down the Zenroom version you are using!

```
rule check version 1.0.0
```

## Input

Data provided as input (from **data** and **keys**) is all imported
automatically from JSON or CBOR binary formats.


```yaml
given:
  - {given: nothing} # checks input is really empty
  - {given: 'I introduce myself as '''''} # open a section { "WhoAmI": ... }
  - {given: 'I am known as '''''} # same as above
  - {given: 'I am '''''} # same as above
  - {given: 'I have a valid '''''} # import data named validated with same name schema
  - {given: 'I have a '''''} # import data named without validation
  - {given: 'I have my valid '''''} # import data named validated under my section
  - {given: 'I have my '''''} # import data named under my section without validation
  - {given: 'I have inside '''' a valid '''''} # import validated data from inside a section 
  - {given: 'I have inside '''' a '''''} # import data from inside a section
  - {given: 'I have a valid '''' inside '''''} # same as above, inverted order of arguments
  - {given: 'I have a valid '''' in '''''} # same as above
  - {given: 'I have a valid '''' from '''''} # same as above (courtesy synonyms)
  - {given: 'I have a '''' inside '''''} # and more courtesy
  - {given: 'I have a '''' in '''''}
  - {given: 'I have a '''' from '''''}
  - {given: 'I have a valid '''' from '''''}
  - {given: 'I set '''' to '''''} # 
  - {given: 'the '''' is valid'}
```

Settings:
```txt
rule input encoding [ url64 | base64 | hex | bin ]
rule input format [ json | cbor ]
```
## Output

Output is all exported in JSON or CBOR

```yaml
then:
  - {then: 'print '''' '''''}
  - {then: 'print all data'}
  - {then: 'print my data'}
  - {then: 'print my data'}
  - {then: 'print my '''''}
  - {then: 'print as '''' my '''''}
  - {then: 'print my '''' as '''''}
  - {then: 'print the '''''}
  - {then: 'print as '''' the '''''}
  - {then: 'print as '''' the '''' inside '''''}
```

Settings:
```txt
rule output encoding [ url64 | base64 | hex | bin ]
rule output format [ json | cbor ]
```
# Symmetric encryption 

This is a simple tecnique to hide a secret using a common password known to all people.

```yaml
  # if a 'header' is set will authenticate to destination
  - {when: 'I encrypt the '''' to '''' with '''''}
  - {when: 'I decrypt the '''' to '''' with '''''}
```

Let's imagine two people who want to communicate secretly: Alice and Bob.

![Zencode to encrypt with password](img/aes_crypt.svg)

Here the Zencode is executed three times:

1. Alice generates a strong random password
2. Alice encrypts a message using this password
3. Bob decrypts the message using the password

Of course the password must be communicated to Bob and that's the
dangerous part, since it could be stolen at the moment is told.

# Asymmetric encryption

To solve this problem we have [asymmetric encryption (or public key
cryptography)](https://en.wikipedia.org/wiki/Public-key_cryptography)
which relies on the creation of keypairs (public and private) both by
Alice and Bob.

Fortunately its pretty simple to do using Zencode.

## Key generation and exchange

```yaml
  - {when: 'I create my new keypair'}
  - {when: 'I generate my keys'}
```

![Zencode to generate asymmetric keypairs](img/ecdh_keygen.svg)

After both Alice and Bob have their own keypairs and they both know
each other public key we can move forward to do asymmetric encryption
and signatures.

## Public-key Encryption (ECDH)

```yaml
  # if a 'header' is set will authenticate to destination
  - {when: 'I encrypt the '''' to '''' for '''''}
  - {when: 'I decrypt the '''' from '''' to '''''}
```

![Zencode to encrypt using asymmetric keypairs](img/ecdh_crypt.svg)

In this basic example the session key for encryption is made combining
the private key of Alice and the public key of Bob (or
viceversa).

Reusing keys is not really considered secure, but by combining the
first symmetric key example and this one is possible to generate a
random password, use it to encrypt the message and then use the
session key to encrypt the password.

There is also the possibility to add an authenticated clear text
header to the message, using an additional line of Zencode:

```cucumber
When I write 'my secret for you' in 'message'
and I write 'an authenticated message' in 'header'
```

The decryption will always check that the header hasn't changed,
maintaining the integrity of the string which may contain important
public information that accompany the secret.

## Public-key Signature (ECDSA)

```yaml
  - {when: 'I sign the '''' as '''''}
  - {when: 'I verify the '''' is authentic'}
```

![Zencode to sign using asymmetric keypairs](img/ecdsa_sign.svg)

In this example Alice uses her private key to sign and authenticate a
message. Bob or anyone else can use Alice's public key to prove that
the integrity of the message is kept intact and that she signed it.

# List of statements

```yaml
<%= echo "$(./parse_zencode.sh | json2yaml -)" %>
```
