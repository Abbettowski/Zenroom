# Smart contracts in human language

Zenroom is software inspired by the [language-theoretical
security](http://langsec.org) research and it allows to express
cryptographic operations in a readable domain-specific language called
**Zencode**.

For an explanation of the innovation brought by Zencode see this blog post: [Smart contracts for the English speaker](https://decodeproject.eu/blog/smart-contracts-english-speaker).

Now to learn this very simple language, lets dive into some examples.

Keep in mind that statements in yellow boxes are actual Zencode being executed.

# Memory model

Zencode contracts operate in 3 phases:

1. **Given** - validates the input
2. **When** - processes the contents
3. **Then** - prints out the results

The 3 separate blocks of code also correspond to 3 separate memory areas, sealed by some security measures.

![Zencode documentation diagram](img/zencode_diagram.png)

All data processed has first to pass the validation phase according to scenario specific data schemas.

**Good Practice**: start your Zencode noting down the Zenroom version you are using!

```
rule check version 1.0.0
```

## Given

Data provided as input (from **data** and **keys**) is all imported
automatically from JSON or CBOR binary formats.

Here below a dense representation of the main operations available.

**Self introduction** (affects "**my**" statements)
```yaml
given:
  - {given: nothing} # checks input is really empty
  - {given: 'I introduce myself as '''''} # open a section { "WhoAmI": ... }
  - {given: 'I am known as '''''} # same as above
  - {given: 'I am '''''} # same as above
```

**Import given data**
```yaml
  - {given: 'I have a '''''} # import data named without validation
  - {given: 'I have my '''''} # import data named under my section without validation
  - {given: 'I have inside '''' a '''''} # import data from inside a section
  - {given: 'I have a '''' inside '''''} # different statement, invert order of arguments
  - {given: 'I have a '''' in '''''}     # courtesy synonyms ...
  - {given: 'I have a '''' from '''''}   # ... are the same
```

**Import only "valid" data** (schemas are set by the "**scenario**")
```yaml
  - {given: 'I have a valid '''''} # import data named validated with same name schema
  - {given: 'I have my valid '''''} # import data named validated under my section
  - {given: 'I have inside '''' a valid '''''} # import validated data from inside a section 
  - {given: 'I have a valid '''' inside '''''} # same as above, inverted order of arguments
  - {given: 'I have a valid '''' in '''''} # same as above
  - {given: 'I have a valid '''' from '''''} # same as above (courtesy synonyms)
  - {given: 'the '''' is valid'} # validate an already imported data object
```

Settings:
```txt
rule input encoding [ url64 | base64 | hex | bin ]
rule input format [ json | cbor ]
```

## When

Processing data is done in the when block. Also scenarios add statements to this block.

Without extensions, these are the basic functions available

```yaml
when:
  - {when: 'I append '''' to '''''}
  - {when: 'I write '''' in '''''}
  - {when: 'I set '''' to '''''}
  - {when: 'I create a random '''''}
  - {when: 'I create a random array of '''' elements'}
  - {when: 'I create a random '''' bit array of '''' elements'}
  - {when: 'I set '''' as '''' with '''''}
  - {when: 'I append '''' as '''' to '''''}
  - {when: 'I write '''' as '''' in '''''}
```

## Then

Output is all exported in JSON or CBOR

```yaml
then:
  - {then: 'print '''' '''''}
  - {then: 'print all data'}
  - {then: 'print my data'}
  - {then: 'print my data'}
  - {then: 'print my '''''}
  - {then: 'print as '''' my '''''}
  - {then: 'print my '''' as '''''}
  - {then: 'print the '''''}
  - {then: 'print as '''' the '''''}
  - {then: 'print as '''' the '''' inside '''''}
```

Settings:
```txt
rule output encoding [ url64 | base64 | hex | bin ]
rule output format [ json | cbor ]
```
# Symmetric encryption 

This is a simple tecnique to hide a secret using a common password known to all people.

```yaml
# a `message` must be set and will be used as encryption input 
# if a `header` is set will authenticate to destination
  - {when: 'I encrypt the message with '''''}
  - {when: 'I decrypt the secret message with '''''}
# encryption output is returned in `secret message`
```

Let's imagine I want to share a secret with someone and send secret messages encrypted with it:

![Zencode to encrypt with password](img/aes_crypt.svg)

I will need 3 Zencode contracts executed at different times:

**1. I generate a strong random secret**
```cucumber
<%= "$(cat ../test/zencode_simple/SYM01.zen)" %>
```
-> then save the secret output and send it

**2. I encrypt a message using this secret**
```cucumber
<%= "$(cat ../test/zencode_simple/SYM02.zen)" %>
```
-> then save the secret message and send it

**3. Who has my secret can decrypt the secret message**
```cucumber
<%= "$(cat ../test/zencode_simple/SYM03.zen)" %>
```

Of course the secret must be known by all participats and that's the
dangerous part, since it could be stolen at the moment is told.

We solve this problem using public-key cryptography, also known as a-symmetric encryption.

# Asymmetric encryption

To solve this problem we have [asymmetric encryption (or public key
cryptography)](https://en.wikipedia.org/wiki/Public-key_cryptography)
which relies on the creation of keypairs (public and private) both by
Alice and Bob.

Fortunately its pretty simple to do using Zencode.

## Key generation and exchange

```yaml
  - {when: 'I create my new keypair'}
  - {when: 'I generate my keys'}
```

![Zencode to generate asymmetric keypairs](img/ecdh_keygen.svg)

After both Alice and Bob have their own keypairs and they both know
each other public key we can move forward to do asymmetric encryption
and signatures.

**1.a Alice keygen**
```cucumber
<%= "$(cat ../test/zencode_simple/AES01.zen)" %>
```

**2.a Alice pubkey**
```cucumber
<%= "$(cat ../test/zencode_simple/AES02.zen)" %>
```

**1.b Bob keygen**
```cucumber
<%= "$(cat ../test/zencode_simple/AES03.zen)" %>
```

**2.b Bob pubkey**
```cucumber
<%= "$(cat ../test/zencode_simple/AES04.zen)" %>
```

## Public-key Encryption (ECDH)

```yaml
  # if a 'header' is set will authenticate to destination
  - {when: 'I encrypt the '''' to '''' for '''''}
  - {when: 'I decrypt the '''' from '''' to '''''}
```

![Zencode to encrypt using asymmetric keypairs](img/ecdh_crypt.svg)


**1. Alice encrypts the message using Bob's public key**
```cucumber
<%= "$(cat ../test/zencode_simple/AES05.zen)" %>
```

**2. Bob prepares a keyring with Alice's public key**
```cucumber
<%= "$(cat ../test/zencode_simple/AES06.zen)" %>
```

**3. Bob decrypts the message using Alice's public key**
```cucumber
<%= "$(cat ../test/zencode_simple/AES07.zen)" %>
```

In this basic example the session key for encryption is made combining
the private key of Alice and the public key of Bob (or
viceversa).

```cucumber
When I write 'my secret for you' in 'message'
and I write 'an authenticated message' in 'header'
```

The decryption will always check that the header hasn't changed,
maintaining the integrity of the string which may contain important
public information that accompany the secret.

## Public-key Signature (ECDSA)

```yaml
  - {when: 'I sign the '''' as '''''}
  - {when: 'I verify the '''' is authentic'}
```

![Zencode to sign using asymmetric keypairs](img/ecdsa_sign.svg)

Here we continue assuming that the keyrings are already prepared with
public/private keypairs and the public keypair of the correspondent.

**1. Alice signs a message for Bob**
```cucumber
<%= "$(cat ../test/zencode_simple/DSA01.zen)" %>
```

**1. Bob verifies the signed message from Alice**
```cucumber
<%= "$(cat ../test/zencode_simple/DSA02.zen)" %>
```

In this example Alice uses her private key to sign and authenticate a
message. Bob or anyone else can use Alice's public key to prove that
the integrity of the message is kept intact and that she signed it.






# Zero Knowledge Proofs

One powerful feature of Zenroom is the implementation of the [Coconut
crypto scheme](https://arxiv.org/pdf/1802.07344.pdf). This novel
scheme supports several features based on pairing elliptic curve
arithmetics and in particular:

- non-interactive zero knowedge proofs (also known as ZK, ZKP or ZK-Snarks)
- threshold credentials with multiple decentralised issuers
- homomorphic encryption for numeric counters

These are all very useful features for architectures based on the
decentralisation of trust, typical of DLT and blockchain based
systems, as well for off-line and non-interactive authentication.

The Zencode language leverages two main use cases of this crypto
scheme and two more will be implemented in the future.

1. Attribute Based Credentials (ABC) where issuer verification keys
   represent specific credentials
2. A Petition system based on ABC and homomorphic encryption
3. (WIP) Anonymous proxy validation scheme
4. (WIP) Token thumbler to privately transfer numeric assets

The main feature of ZKP based cryptography is that one can use
credentials to create untreaceable public proofs for authenticating or
signing a petition etc.

The validity of ZK proofs can be witnesses by anyone without even
knowing who is being authenticated: just knowing the proof and the
credential (the public verification key of the credential issuer).

## Attribute Based Credentials

![Alice in Wonderland](img/alice_with_cards-sm.jpg)

Let's now imagine 3 different subjects for our scenarios:

1. **Wonderland** is an open space, all inhabitants can witness the validity of **credential proofs**
2. **Alice** just arrived in Wonderland: she will make **credential signature requests**, hold the signed **credentials** and use them to produce **proofs**
3. **Mad Hatter** is a well known **credential issuer** in Wonderland: he receives **credential signature requests** and decides if to sign them. Once signed, **credentials** can be used to produce **proofs**.

Credential proofs are different at every use, so Alice can use signed
credentials in her possession to produce proofs, but cannot be
followed by her trail of proofs. Alice can produce an infinite number
of them and leave them around: like in a chest at the entrance of a
room, for anyone to witness their validity without even meeting Alice
or knowing who she is.

![Zencode for attribute based credentials](img/zkp_abc.svg)

1- **Alice** generates her **credential keypair**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED01.zen)" %>
```
2- **MadHatter** generates an **issuer keypair**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED03.zen)" %>
```
2a **MadHatter** publishes the **verification key**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED04.zen)" %>
```
3- **Alice** sends her **credential signature request**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED02.zen)" %>
```
4- **MadHatter** decides to sign a **credential signature request**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED05.zen)" %>
```
5- **Alice** receives and aggregates the signed **credential**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED06.zen)" %>
```

-----

At this point **Alice** is in possession of **credentials** allowing
her to produce a **proof** any time she wants.

-----

6- **Alice** show the **credential proof**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED07.zen)" %>
```

7- Anyone can verify the **credential proof**
```cucumber
<%= "$(cat ../test/zencode_coconut/CRED08.zen)" %>
```


# Full list of statements

```yaml
<%= "$(cat zencode_utterances.yaml)" %>
```
